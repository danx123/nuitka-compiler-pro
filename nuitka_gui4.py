import sys
import os
import subprocess
import threading
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit,
    QFileDialog, QTextEdit, QCheckBox, QLabel, QGroupBox, QDialog, QFormLayout,
    QDialogButtonBox
)
from PyQt6.QtCore import QObject, pyqtSignal, QThread
from PyQt6.QtGui import QIcon

# --- New Class: Dialog Window for Version Generator ---
class VersionDialog(QDialog):
    def __init__(self, parent=None, script_path=None, existing_version_file=None):
        super().__init__(parent)
        self.setWindowTitle("Version.txt Generator / Editor")
        self.script_path = script_path
        self.saved_path = None

        # Define the fields to be created
        self.fields = {
            "FileVersion": QLineEdit(),
            "ProductVersion": QLineEdit(),
            "ProductName": QLineEdit(),
            "CompanyName": QLineEdit(),
            "FileDescription": QLineEdit(),
            "InternalName": QLineEdit(),
            "OriginalFilename": QLineEdit(),
            "LegalCopyright": QLineEdit(),
        }

        # Setup Layout
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        for label, editor in self.fields.items():
            editor.setPlaceholderText(f"Enter {label}...")
            form_layout.addRow(label, editor)
        
        layout.addLayout(form_layout)

        # Auto-fill Button
        self.autofill_button = QPushButton("Auto-fill from Script Name")
        self.autofill_button.clicked.connect(self.autofill_from_script)
        if not self.script_path:
            self.autofill_button.setEnabled(False)
            self.autofill_button.setToolTip("Select the Python script in the main window first")
        
        # Save & Cancel Buttons
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        # Combine everything
        h_layout = QHBoxLayout()
        h_layout.addWidget(self.autofill_button)
        h_layout.addStretch()
        layout.addLayout(h_layout)
        layout.addWidget(button_box)
        
        self.setMinimumWidth(450)

        # If a version file exists, load its data
        if existing_version_file and os.path.exists(existing_version_file):
            self.load_data(existing_version_file)

    def load_data(self, file_path):
        """Reads a version.txt file and fills the form."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        key, value = line.split('=', 1)
                        if key.strip() in self.fields:
                            self.fields[key.strip()].setText(value.strip())
        except Exception as e:
            print(f"Error loading version file: {e}") # Can be replaced with a message box

    def autofill_from_script(self):
        """Fills some fields based on the script name."""
        if not self.script_path:
            return
        
        base_name = os.path.basename(self.script_path)
        script_name_no_ext = os.path.splitext(base_name)[0]
        
        product_name = script_name_no_ext.replace('_', ' ').replace('-', ' ').title()
        
        self.fields["ProductName"].setText(product_name)
        self.fields["InternalName"].setText(script_name_no_ext)
        self.fields["OriginalFilename"].setText(f"{script_name_no_ext}.exe")
        self.fields["FileDescription"].setText(f"{product_name} Application")
        if not self.fields["FileVersion"].text():
            self.fields["FileVersion"].setText("1.0.0.0")
        if not self.fields["ProductVersion"].text():
            self.fields["ProductVersion"].setText("1.0.0.0")

    def accept(self):
        """Called when the Save button is pressed."""
        default_filename = "version.txt"
        if self.script_path:
            default_path = os.path.join(os.path.dirname(self.script_path), default_filename)
        else:
            default_path = default_filename
            
        file_path, _ = QFileDialog.getSaveFileName(self, "Save as...", default_path, "Text Files (*.txt)")

        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("# Auto-generated by Nuitka GUI\n")
                    for label, editor in self.fields.items():
                        f.write(f"{label}={editor.text()}\n")
                self.saved_path = file_path
                super().accept() # Close the dialog
            except Exception as e:
                # It's better to show an error message to the user here
                print(f"Failed to save file: {e}")


# --- Worker Thread (Unchanged) ---
class CompilerWorker(QObject):
    progress_update = pyqtSignal(str)
    finished = pyqtSignal(str)
    
    def __init__(self, command): 
        super().__init__()
        self.command = command
    
    def run(self):
        try:
            self.process = subprocess.Popen(self.command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8', errors='replace', shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
            while True:
                output = self.process.stdout.readline()
                if output == '' and self.process.poll() is not None: 
                    break
                if output: 
                    self.progress_update.emit(output.strip())
            self.process.wait()
            rc = self.process.poll()
            if rc == 0: 
                self.finished.emit("\n--- COMPILATION SUCCESSFUL! ---")
            else: 
                self.finished.emit(f"\n--- COMPILATION FAILED (Error Code: {rc}) ---")
        except Exception as e: 
            self.finished.emit(f"\n--- A CRITICAL ERROR OCCURRED ---\n{str(e)}")


# --- Main Application Window (Modified) ---
class NuitkaGui(QWidget):
    def __init__(self):
        super().__init__()
        self.thread = None
        self.worker = None
        self.initUI()

    def initUI(self):
        self.setWindowTitle('Nuitka Compiler Pro - by Danx')
        self.setGeometry(100, 100, 600, 500)
        icon_path = "compiler.ico"
        if hasattr(sys, "_MEIPASS"):
            icon_path = os.path.join(sys._MEIPASS, icon_path)
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))
        main_layout = QVBoxLayout()

        # Input & Output Group
        io_group = QGroupBox("Input & Output")
        io_layout = QVBoxLayout()
        self.script_path_layout = self.create_file_selector("Select Python Script (.py)", self.select_script, "Select Python file...")
        io_layout.addLayout(self.script_path_layout)
        self.output_dir_layout = self.create_file_selector("Output Directory", self.select_output_dir, "Select output folder...", is_folder=True)
        io_layout.addLayout(self.output_dir_layout)
        io_group.setLayout(io_layout)
        main_layout.addWidget(io_group)

        # Compilation Options Group
        options_group = QGroupBox("Compilation Options")
        options_layout = QVBoxLayout()
        self.onefile_check = QCheckBox("One-File Mode (single .exe)")
        self.onefile_check.setToolTip("If unchecked, will produce a folder (One-Directory)")
        self.disable_console_check = QCheckBox("Disable Console Window")
        options_layout.addWidget(self.onefile_check)
        options_layout.addWidget(self.disable_console_check)
        self.icon_path_layout = self.create_file_selector("Select Icon (.ico)", self.select_icon, "Select icon file...")
        options_layout.addLayout(self.icon_path_layout)
        options_group.setLayout(options_layout)
        main_layout.addWidget(options_group)

        # --- MODIFICATION: Application Version Information Section ---
        version_group = QGroupBox("Application Version Information")
        version_layout = QHBoxLayout()
        self.version_file_edit = QLineEdit()
        self.version_file_edit.setPlaceholderText("Select or create a version file...")
        version_gen_button = QPushButton("Create / Edit Version File...")
        version_gen_button.clicked.connect(self.open_version_generator)
        version_layout.addWidget(QLabel("Version File:"))
        version_layout.addWidget(self.version_file_edit)
        version_layout.addWidget(version_gen_button)
        version_group.setLayout(version_layout)
        main_layout.addWidget(version_group)

        # Data Inclusion Group
        data_group = QGroupBox("Include Additional Files & Folders")
        data_layout = QVBoxLayout()
        data_layout.addWidget(QLabel("Include Files (comma-separated):"))
        self.include_files_edit = QLineEdit()
        self.include_files_edit.setPlaceholderText("e.g., image.png,data/config.json")
        data_layout.addWidget(self.include_files_edit)
        data_layout.addWidget(QLabel("Include Folders (comma-separated):"))
        self.include_dirs_edit = QLineEdit()
        self.include_dirs_edit.setPlaceholderText("e.g., assets,templates")
        data_layout.addWidget(self.include_dirs_edit)
        data_group.setLayout(data_layout)
        main_layout.addWidget(data_group)
        
        # Log Group
        log_group = QGroupBox("Compilation Log")
        log_layout = QVBoxLayout()
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        self.log_output.setStyleSheet("background-color: #2b2b2b; color: #f0f0f0; font-family: Consolas, monaco, monospace;")
        log_layout.addWidget(self.log_output)
        log_group.setLayout(log_layout)
        main_layout.addWidget(log_group)

        # Control Buttons
        control_layout = QHBoxLayout()
        self.preview_cmd_button = QPushButton("Preview Command")
        self.preview_cmd_button.clicked.connect(self.preview_command)
        self.clear_log_button = QPushButton("Clear Log")
        self.clear_log_button.clicked.connect(self.clear_log)
        self.compile_button = QPushButton("Start Compilation")
        self.compile_button.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
        self.compile_button.clicked.connect(self.run_compilation)
        control_layout.addWidget(self.preview_cmd_button)
        control_layout.addWidget(self.clear_log_button)
        control_layout.addStretch()
        control_layout.addWidget(self.compile_button)
        main_layout.addLayout(control_layout)
        
        self.setLayout(main_layout)

    # --- NEW FUNCTION: To open the generator dialog ---
    def open_version_generator(self):
        script_path = self.script_path_layout.itemAt(1).widget().text()
        current_version_file = self.version_file_edit.text()
        
        dialog = VersionDialog(self, script_path=script_path, existing_version_file=current_version_file)
        if dialog.exec(): # Show the dialog and wait for it to be closed
            # If the user pressed "Save"
            if dialog.saved_path:
                self.version_file_edit.setText(dialog.saved_path)

    def create_file_selector(self, label_text, connect_func, placeholder, is_folder=False):
        layout = QHBoxLayout()
        label = QLabel(label_text)
        line_edit = QLineEdit()
        line_edit.setPlaceholderText(placeholder)
        button = QPushButton("Browse...")
        button.clicked.connect(lambda: connect_func(line_edit))
        layout.addWidget(label)
        layout.addWidget(line_edit)
        layout.addWidget(button)
        return layout

    def select_script(self, line_edit):
        fname, _ = QFileDialog.getOpenFileName(self, 'Select Python Script', '', 'Python Files (*.py *.pyw)')
        if fname: 
            line_edit.setText(fname)

    def select_icon(self, line_edit):
        fname, _ = QFileDialog.getOpenFileName(self, 'Select Icon File', '', 'Icon Files (*.ico)')
        if fname: 
            line_edit.setText(fname)

    def select_output_dir(self, line_edit):
        dname = QFileDialog.getExistingDirectory(self, 'Select Output Directory')
        if dname: 
            line_edit.setText(dname)

    def build_command(self):
        script_path = self.script_path_layout.itemAt(1).widget().text()
        if not script_path:
            self.log_output.append("<font color='red'>ERROR: Python script not selected!</font>")
            return None

        command = ["python", "-m", "nuitka", f'"{script_path}"']
        
        command.append("--standalone")
        if self.onefile_check.isChecked(): 
            command.append("--onefile")
        if self.disable_console_check.isChecked(): 
            command.append("--windows-disable-console")

        output_dir = self.output_dir_layout.itemAt(1).widget().text()
        if output_dir: 
            command.append(f'--output-dir="{output_dir}"')

        icon_path = self.icon_path_layout.itemAt(1).widget().text()
        if icon_path: 
            command.append(f'--windows-icon-from-ico="{icon_path}"')
            
        version_file_path = self.version_file_edit.text()
        if version_file_path and os.path.exists(version_file_path):
            try:
                version_map = {
                    "FileVersion": "--windows-file-version", 
                    "ProductVersion": "--windows-product-version", 
                    "ProductName": "--windows-product-name", 
                    "CompanyName": "--windows-company-name", 
                    "FileDescription": "--windows-file-description", 
                    "InternalName": "--windows-internal-name", 
                    "OriginalFilename": "--windows-original-filename", 
                    "LegalCopyright": "--windows-legal-copyright"
                }
                with open(version_file_path, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            key, value = line.split('=', 1)
                            key, value = key.strip(), value.strip()
                            if key in version_map: 
                                command.append(f'{version_map[key]}="{value}"')
            except Exception as e: 
                self.log_output.append(f"<font color='orange'>WARNING: Failed to process version file: {e}</font>")
        
        include_files = self.include_files_edit.text().strip()
        if include_files:
            for item in include_files.split(','): 
                item = item.strip()
                command.append(f'--include-data-file="{item}={os.path.basename(item)}"')
        
        include_dirs = self.include_dirs_edit.text().strip()
        if include_dirs:
            for item in include_dirs.split(','): 
                item = item.strip()
                command.append(f'--include-data-dir="{item}={item}"')
        
        command.extend(["--show-progress", "--show-memory", "--jobs=4", "--remove-output", "--msvc=latest"])
        return " ".join(command)
        
    def preview_command(self): 
        command = self.build_command()
        self.log_output.append(f"\n--- Command to be executed ---\n{command}\n--------------------------------\n")
    
    def clear_log(self): 
        self.log_output.clear()
        
    def run_compilation(self):
        command_str = self.build_command()
        if not command_str: 
            return
        self.clear_log()
        self.log_output.append(f"--- Starting Compilation Process ---\nCommand: {command_str}\n")
        self.compile_button.setEnabled(False)
        self.compile_button.setText("Compiling...")
        
        self.thread = QThread()
        self.worker = CompilerWorker(command_str)
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.compilation_finished)
        self.worker.progress_update.connect(self.update_log)
        self.thread.start()
        
    def update_log(self, text): 
        self.log_output.append(text)
        
    def compilation_finished(self, message):
        self.log_output.append(f"<font color='lime'>{message}</font>")
        self.compile_button.setEnabled(True)
        self.compile_button.setText("Start Compilation")
        self.thread.quit()
        self.thread.wait()

def main():
    app = QApplication(sys.argv)
    ex = NuitkaGui()
    ex.show()
    sys.exit(app.exec())

if __name__ == '__main__':
    main()